<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Shelly Plus power profiling</title>
  <style>
@import url('https://fonts.googleapis.com/css2?family=Bai+Jamjuree:wght@400&family=Nunito+Sans:wght@400&display=swap');

* { box-sizing: border-box; }
html, body {
  font-family: "Nunito Sans", Inter, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  font-size: 16px;
  font-style: normal;
  font-weight: 400;
  line-height: 1.625rem;
  margin: 0;
  padding: 0;
  margin-left: auto;
  margin-right: auto;
  color: #042f2e;
  background-color: #ffffff;
}

@media (min-width: 576px) {
  body {
    max-width: 540px;
  }
}
@media (min-width: 768px) {
  body {
    max-width: 720px;
  }
}
@media (min-width: 992px) {
  body {
    max-width: 960px;
  }
}
@media (min-width: 1200px) {
  body {
    max-width: 1140px;
  }
}
@media (min-width: 1400px) {
  body {
    max-width: 1320px;
  }
}

h1 {
  font-family: "Bai Jamjuree", system-ui, sans-serif;
  font-size: 2.5rem;
  line-height: 3rem;
  font-weight: 400;
  letter-spacing: 0;
  margin-top: 0;
  margin-bottom: 0;
  color: #042f2e;
}

@media (min-width: 450px) {
  h1 {
    font-size: 3.25rem;
    line-height: 3.9rem;
  }
}

h1 span {
  color: #064e3b;
}

header {
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
  min-height: 72px;
  padding-block: 12px !important;
  padding: 12px 24px;
  align-items: center !important;
  display: flex !important;
  flex-wrap: wrap !important;
}

@media (min-width: 768px) {
  header {
    padding: 12px 72px;
  }
}

header > * {
  display: flex;
}

header > :first-child {
  margin-right: auto !important;
}

h3 {
  font-family: "Bai Jamjuree", system-ui, sans-serif;
  font-size: 1.46rem;
  line-height: 2.2rem;
  font-weight: 400;
  letter-spacing: 0;
  margin: 0;
  color: #042f2e;
}

h3 span {
  color: #064e3b;
  font-weight: 400;
}

.content {
  padding: 48px 24px;
}

@media (min-width: 768px) {
  .content {
    padding: 64px 72px;
  }
}

p {
  margin-top: 0;
  margin-bottom: 1rem;
}

code {
  background-color: #f3f4f6;
  padding: 0.2em 0.4em;
  border-radius: 4px;
  font-family: "Courier New", Courier, monospace;
  font-size: 0.9em;
}

input[type="text"] {
  border: 1px solid #064e3b88;
  border-radius: 4px;
  padding: 2px 4px;
  font-family: inherit;
  font-size: 0.9em;
}

.profile {
  color: #042f2e;
  border-radius: 0px;
  overflow: hidden;
  margin-bottom: 1em;
}
.profile > div {
  padding-top: 1px;
  border-left: 5px solid #064e3b88;
  border-right: 5px solid #064e3b88;
  position: relative;
  padding-bottom: calc(5% - 1px);
}
.profile > div:first-of-type {
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
  border-top: 5px solid #064e3b88;
  overflow: hidden;
}
.profile > div + div {
  border-top: solid 1.5px #064e3b88;
}
.profile > div > svg {
  position: absolute;
}
.profile > div + div::after {
  content: "";
  position: absolute;
  top: -1px;
  left: 0;
  right: 0;
  height: 1px;
  background-color: #064e3b88;
  pointer-events: none;
}
.profile path {
  fill: #064e3b88;
  stroke: #042f2e;
  stroke-width: 6px;
  stroke-linejoin: bevel;
}
/* stroke-width = 3px * (viewBox width = 2400px) / min-width */
@media (min-width: 600px) {
  .profile path {
    stroke-width: 12px;
  }
}
@media (min-width: 720px) {
  .profile path {
    stroke-width: 10px;
  }
}
@media (min-width: 900px) {
  .profile path {
    stroke-width: 8px;
  }
}
@media (min-width: 1020px) {
  .profile path {
    stroke-width: 7px;
  }
}
@media (min-width: 1200px) {
  .profile path {
    stroke-width: 6px;
  }
}
@media (min-width: 1440px) {
  .profile path {
    stroke-width: 5px;
  }
}
@media (min-width: 1800px) {
  .profile path {
    stroke-width: 4px;
  }
}
@media (min-width: 2400px) {
  .profile path {
    stroke-width: 3px;
  }
}
@media (min-width: 3400px) {
  .profile path {
    stroke-width: 2px;
  }
}
.profile > p {
  font-weight: bold;
  margin: 0;
  background-color: #064e3b88;
  color: #042f2e;
  border: 5px solid transparent;
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
  border-top: none;
}
.profile > p:before {
  border-top: 1px solid #e5e7eb;
  display: block;
  content: "";
}


.chart-tooltip {
  position: absolute;
  background: #042f2e;
  color: #e5e7eb;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 0.9em;
  pointer-events: none;
  z-index: 100;
  display: none;
}

#switchPowerLine:empty {
  display: none;
}

#switchPowerLine {
  margin: 0.5rem 0;
}

#switchPowerLine > span {
  display: inline-block;
  min-width: 8em;
  text-align: left;
  margin-right: 2rem;
}

#switchPowerLine > span:last-child {
  margin-right: 0;
}

.profile > table {
  margin-top: 0.5em;
  width: 100%;
  float: left;
  background-color: #064e3b88;
  border-radius: 8px;
  margin-right: 0.25em;
  table-layout: fixed;
}

.profile > table.power {
  margin-right: 0;
}

.profile > table.power td {
  text-align: center;
}

.profile > table a {
  color: #e5e7eb;
}

@media (min-width: 992px) {
  .profile > table {
    width: 50%;
    width: calc(50% - 0.25em);
  }
  .profile > table.power {
    margin-left: 0.25em;
  }
}

.profile > table td {
  padding: .1em .5em;
  background-color: #042f2e;
  color: #e5e7eb;
  min-width: 4em;
}

.profile > table th {
  padding: .1em .5em;
  background-color: transparent;
  color: #042f2e;
  font-weight: bold;
  text-align: center;
}


.profile > table tr:first-child td:first-child {
  border-top-left-radius: 6px;
}

.profile > table tr:first-child td:last-child {
  border-top-right-radius: 6px;
}

.profile > table tr:last-child td:first-child {
  border-bottom-left-radius: 6px;
}

.profile > table tr:last-child td:last-child {
  border-bottom-right-radius: 6px;
}

.profile > table.power tr:last-of-type > td:first-of-type {
  border-radius: 0px;
}

.profile > table.power tr:first-of-type > td:last-of-type {
  border-bottom-right-radius: 0px;
}

.profile > table.power tr:last-of-type > td:last-of-type {
  border-top-right-radius: 0px;
}

.profiler-link {
  background-position: center;
  background-repeat: no-repeat;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="%23042f2e" fill-opacity="context-fill-opacity"><path d="M8 0A8 8 0 0 0 .78 11.43a1 1 0 1 0 1.8-.86 5.94 5.94 0 0 1 0-5.17 6 6 0 0 1 10.83 5.17 1 1 0 1 0 1.81.86A7.99 7.99 0 0 0 8 0M10 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0M10.96 6.7a.5.5 0 1 0-.92-.4l-1.7 3.73a2 2 0 0 1 .92.41l1.7-3.73z"/></svg>');
  float: right;
  width: 26px;
  height: 26px;
  padding: 5px;
}

.profiler-link:hover {
  background-color: #73737344;
}

a {
  color: #064e3b;
  text-decoration: underline;
}

a:hover {
  color: #042f2e;
  text-decoration: none;
}

footer {
  text-align: center;
  font-size: smaller;
  border-top: 1px solid rgba(0, 0, 0, 0.12);
  padding-top: 2rem !important;
  margin-top: 3rem;
  color: #374151;
}
footer img {
  height: 22px !important;
  width: auto;
  margin-left: 3px;
  vertical-align: text-bottom;
}
footer a {
  color: #374151;
}

.status-indicator {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.5em;
  vertical-align: middle;
  transition: opacity 0.3s;
}

#statusText {
  vertical-align: middle;
}

.content:not(.has-data) > *:not(:first-child) {
  visibility: hidden;
}

.status-indicator circle {
  fill: none;
  stroke-width: 2;
}

.status-indicator circle:first-child {
  stroke: #064e3b22;
}

.status-indicator #statusProgress {
  stroke: #064e3b88;
  stroke-dasharray: 50.265;
  stroke-dashoffset: 50.265;
  transform: rotate(-90deg);
  transform-origin: 50% 50%;
}

.status-indicator.fetching #statusProgress {
  stroke-dashoffset: 50.265;
}

.status-indicator.waiting #statusProgress {
  animation: fillCircle 5s linear forwards;
}

@keyframes fillCircle {
  from {
    stroke-dashoffset: 50.265;
  }
  to {
    stroke-dashoffset: 0;
  }
}

.status-indicator.error #statusProgress {
  stroke: #dc2626 !important;
  stroke-dashoffset: 0 !important;
}

.status-indicator.stale {
  opacity: 0.3;
}

.status-indicator.stale #statusProgress {
  stroke-dashoffset: 0;
}

.switch-name {
  cursor: text;
  border-bottom: 1px dotted transparent;
}

.switch-name:hover {
  border-bottom-color: #064e3b;
  background-color: #f3f4f6;
}

.profile > div > svg > circle {
  fill: #042f2e;
}

#debugLog {
  background-color: #000;
  color: #00ff00;
  font-family: 'Courier New', Courier, monospace;
  font-size: 12px;
  line-height: 1.2;
  padding: 10px;
  height: 300px;
  overflow-y: auto;
  border: 1px solid #ccc;
}

.debug-message {
  white-space: pre-wrap;
  word-wrap: break-word;
  margin: 0;
  padding: 0;
}

.debug-message.level-error {
  color: #ff4444;
}

.debug-message.level-warn {
  color: #ffaa00;
}

.debug-message.level-info {
  color: #cccccc;
}

.debug-message.level-debug {
  color: #00aaff;
}

.debug-message.level-verbose {
  color: #888888;
}

#debugControls {
  visibility: hidden;
  display: flex;
}

#debugArea {
  display: none;
}

#debugSection.debug-enabled #debugControls {
  visibility: visible;
}

#debugSection.debug-enabled #debugArea {
  display: block;
}

#debugHeader {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

#debugControls {
  align-items: center;
  gap: 10px;
}

#debugCount {
  font-size: 12px;
  color: #666;
}

#debugFilter {
  width: 300px;
  padding: 5px;
}

.debug-message.hidden {
  display: none;
}

  </style>
</head>
<body>
  <header>
    <div>
      <h3>Shelly Power Profiling<span id="deviceNameH1"></span></h3>
    </div>
    <div>
      <a href="https://github.com/fqueze/shelly-plus-power-profiling" target="_blank" title="View on GitHub" style="display: flex; align-items: center; padding: 0.5rem;">
        <svg width="24" height="24" viewBox="0 0 16 16" fill="currentColor">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
        </svg>
      </a>
    </div>
  </header>
  <div class="content">
    <p>Shelly script URL: <code>http://<input type=text id="ip" value="192.168.1.89">/<input type="text" id="scriptPath" value="script/1/power"></code> <svg id="statusIndicator" class="status-indicator" viewBox="0 0 20 20">
      <circle cx="10" cy="10" r="8" />
      <circle id="statusProgress" cx="10" cy="10" r="8" />
    </svg><span id="statusText">Waiting for initial data...</span></p>
    <h1 id="power">Live profile: <span id="lastPower">—</span> <span id="lastVoltage"></span></h1>
    <p id="switchPowerLine"></p>
  <div class="profile" id="chartContainer">
    <!-- Main total chart -->
    <div id="totalChart">
      <svg viewBox="0 0 2400 120">
        <path d=""/>
      </svg>
    </div>
    <p id="profileDescription"><span id="deviceNameProfile"></span>, <span id="sampleCount">0</span> samples<a class="profiler-link" target="_blank" title="Open in the Firefox Profiler" id="open" href="#"></a></p>
  </div>
  <div class="profile">
    <table>
      <tr><th>Consumption</th><td><span id="totalEnergy">—</span></td></tr>
      <tr><th>Duration</th><td><span id="totalTime">—</span></td></tr>
      <tr><th rowspan="2">Download as</th><td><a id="csv" href="#">CSV</a></td></tr>
      <tr><td><a id="profile" href="#">profile</a></td></tr>
    </table>
    <table class="power">
      <tr><th rowspan="2">Power</th><td>median</td><td>average</td><td>max</td></tr>
      <tr>
        <td><span id="medianPower">—</span></td>
        <td><span id="averagePower">—</span></td>
        <td><span id="maxPower">—</span></td>
      </tr>
      <tr id="voltageHeaderRow"><th rowspan="2">Voltage</th><td>min</td><td>average</td><td>max</td></tr>
      <tr id="voltageRow">
        <td><span id="minVoltage">—</span></td>
        <td><span id="averageVoltage">—</span></td>
        <td><span id="maxVoltage">—</span></td>
      </tr>
    </table>
  </div>
  <div id="debugSection">
    <h3>Debug</h3>
    <div id="debugHeader">
      <label>
        <input type="checkbox" id="debugCheckbox"> Show debug messages
      </label>
      <div id="debugControls">
        <div id="debugCount"></div>
        <input type="text" id="debugFilter" placeholder="Filter debug messages...">
      </div>
    </div>
    <div id="debugArea">
      <div id="debugLog"></div>
    </div>
  </div>
  </div>
  <script type="application/javascript">
    const UPDATE_INTERVAL_MS = 5000;
    const DEBUG_LEVELS = ['ERROR', 'WARN', 'INFO', 'DEBUG', 'VERBOSE'];
    let shellyPlusPowerData = [];
    let shellyPlusVoltageData = [];
    let shellyPlusFreqData = [];
    let shellyPlusPfData = [];
    let shellySwitchPowerData = []; // For individual switch data from Power Strip Gen4
    let shellyPlusLastIndex = -1;
    let deviceName = "Shelly Plus";
    let deviceInfo = null; // Store full device info for profile metadata
    let switchChartsCreated = false;
    let debugEnabled = false;
    let debugWebSocket = null;
    let debugMessages = []; // Store raw debug messages for profiler
    let memoryData = []; // Memory usage data parsed from debug messages
    let scriptMemoryData = []; // Script-specific memory data from Script.GetStatus
    let cpuData = []; // CPU utilization data from debug messages
    let debugMessageCount = 0;
    let visibleDebugMessageCount = 0;
    // Load switch names from URL hash
    let switchNames = {};
    try {
      if (location.hash) {
        const params = new URLSearchParams(location.hash.substring(1));
        for (const [key, value] of params) {
          if (key.startsWith('s') && /^\d+$/.test(key.substring(1))) {
            const switchId = parseInt(key.substring(1));
            switchNames[switchId] = value;
          }
        }
      }
    } catch (e) {
      // Ignore errors, use empty object
    }

    function setText(id, text) {
      document.getElementById(id).innerHTML = text;
    }

    function updateDebugMessageCount() {
      let text = `${debugMessageCount} messages`;
      if (visibleDebugMessageCount !== debugMessageCount) {
        text = `${visibleDebugMessageCount} / ${text}`;
      }
      document.getElementById('debugCount').textContent = text;
    }

    function addDebugMessage(message, level = null) {
      if (!debugEnabled) {
        return;
      }

      const debugLog = document.getElementById('debugLog');
      const timestamp = new Date().toLocaleTimeString();

      // Check if user is at bottom before adding content
      const wasAtBottom = debugLog.scrollTop >= debugLog.scrollHeight - debugLog.clientHeight - 5;

      // Create message element
      const messageDiv = document.createElement('div');
      messageDiv.className = 'debug-message';
      messageDiv.textContent = `[${timestamp}] ${message}`;
      if (level) {
        messageDiv.dataset.level = level;
        messageDiv.className += ` level-${level.toLowerCase()}`;
      }

      // Apply current filter to new message
      const filterText = document.getElementById('debugFilter').value.toLowerCase();
      if (filterText === '' || messageDiv.textContent.toLowerCase().includes(filterText)) {
        ++visibleDebugMessageCount;
      } else {
        messageDiv.classList.add('hidden');
      }

      debugLog.appendChild(messageDiv);
      ++debugMessageCount;

      // Limit displayed messages for performance (keep last 500 messages)
      const messages = debugLog.children;
      if (messages.length > 500) {
        const removedMessage = messages[0];
        if (!removedMessage.classList.contains('hidden')) {
          --visibleDebugMessageCount;
        }
        --debugMessageCount;
        removedMessage.remove();
      }

      // Only auto-scroll if user was already at bottom
      if (wasAtBottom) {
        debugLog.scrollTop = debugLog.scrollHeight;
      }

      // Update message count
      updateDebugMessageCount();
    }

    const logDebug = addDebugMessage;

    function connectDebugWebSocket() {
      const ip = document.getElementById("ip").value;
      const wsUrl = `ws://${ip}/debug/log`;

      logDebug(`Connecting to debug WebSocket: ${wsUrl}`);
      debugWebSocket = new WebSocket(wsUrl);

      debugWebSocket.onopen = function() {
        logDebug('Debug WebSocket connected');
      };

      debugWebSocket.onmessage = function(event) {
        try {
          const msg = JSON.parse(event.data);

          // Parse combined system and script memory info
          const combinedMatch = msg.data.match(/^sys\s+(\d+)\s+(\d+)\s+(\d+|undefined)\s+(\d+)\s+(\d+)\s+(\d+)$/);
          if (combinedMatch) {
            // System memory data
            const ramSize = parseInt(combinedMatch[1]);
            const ramFree = parseInt(combinedMatch[2]);
            const ramUsed = ramSize - ramFree;
            const memoryPoint = {
              ts: msg.ts,
              ramFree: ramFree,
              ramTotal: ramSize,
              ramUsed: ramUsed,
              usagePercent: Math.round((ramUsed / ramSize) * 100)
            };
            // Only include ramMinFree if it's available (Gen3+ devices only, older devices send 'undefined')
            if (combinedMatch[3] !== 'undefined') {
              memoryPoint.ramMinFree = parseInt(combinedMatch[3]);
            }
            memoryData.push(memoryPoint);

            // Script memory data
            const memUsed = parseInt(combinedMatch[4]);
            const memPeak = parseInt(combinedMatch[5]);
            const memFree = parseInt(combinedMatch[6]);
            scriptMemoryData.push({
              ts: msg.ts,
              memUsed: memUsed,
              memPeak: memPeak,
              memFree: memFree
            });

            // Skip showing this message in debug log and profiler
            return;
          }

          // Parse CPU utilization messages like "shelly_script.cpp:205   script:1 5.2% CPU utilization"
          const cpuMatch = msg.data.match(/^shelly_script\.cpp:\d+\s+script:\d+\s+([\d.]+)%\s+CPU\s+utilization/);
          if (cpuMatch) {
            const cpu = parseFloat(cpuMatch[1]);
            cpuData.push({
              ts: msg.ts,
              cpu: cpu
            });
            // Continue to show this message - it comes from the device, not our script
          }

          // Keep raw messages for profiler markers (only if not filtered above)
          debugMessages.push(msg);

          // Display formatted message
          const timestamp = new Date(msg.ts * 1000).toLocaleTimeString();
          const level = DEBUG_LEVELS[msg.level] || `L${msg.level}`;

          // Add formatted debug message (only show level prefix for non-INFO messages)
          let formattedMessage = msg.data.trim();
          if (level != 'INFO') {
            formattedMessage =  `${level} — ${formattedMessage}`;
          }
          addDebugMessage(formattedMessage, level);
        } catch (e) {
          logDebug(`[RAW] ${event.data}`);
        }
      };

      debugWebSocket.onclose = function(event) {
        const reason = event.reason || 'No reason provided';
        const codeText = event.code === 1006 ? '1006 (abnormal closure)' : event.code;
        logDebug(`Debug WebSocket closed (${codeText}): ${reason}`);
        debugWebSocket = null;

        // Auto-reconnect after 3 seconds if debugging is still enabled
        if (debugEnabled) {
          logDebug('Attempting to reconnect debug WebSocket in 3 seconds...');
          setTimeout(() => {
            if (debugEnabled && !debugWebSocket) {
              connectDebugWebSocket();
            }
          }, 3000);
        }
      };

      debugWebSocket.onerror = function(event) {
        console.log('WebSocket error event:', event);
        logDebug(`Debug WebSocket error: ${event.type} - Connection failed or interrupted`);
      };
    }

    // Setup debug checkbox
    function updateDebugState() {
      debugEnabled = document.getElementById('debugCheckbox').checked;
      const debugSection = document.getElementById('debugSection');

      if (debugEnabled) {
        debugSection.classList.add('debug-enabled');
        logDebug('Debug logging enabled');
        connectDebugWebSocket();
      } else {
        debugSection.classList.remove('debug-enabled');
        if (debugWebSocket) {
          debugWebSocket.close();
          debugWebSocket = null;
        }
        // Clear debug log and stored messages when disabled
        debugMessages = [];
        memoryData = [];
        scriptMemoryData = [];
        cpuData = [];
        debugMessageCount = 0;
        visibleDebugMessageCount = 0;
        document.getElementById('debugLog').innerHTML = '';
        document.getElementById('debugCount').textContent = '';
      }
    }

    document.getElementById('debugCheckbox').addEventListener('change', updateDebugState);

    // Check initial state on page load
    updateDebugState();

    // Setup debug filter
    document.getElementById('debugFilter').addEventListener('input', function(e) {
      const filterText = e.target.value.toLowerCase();
      const debugLog = document.getElementById('debugLog');
      const messages = debugLog.children;

      visibleDebugMessageCount = 0;
      for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        const messageText = message.textContent.toLowerCase();

        if (filterText === '' || messageText.includes(filterText)) {
          message.classList.remove('hidden');
          ++visibleDebugMessageCount;
        } else {
          message.classList.add('hidden');
        }
      }
      // Update message count after filtering
      updateDebugMessageCount();
    });

    function formatDuration(timeS) {
      let result = "";
      if (timeS >= 60) {
        let timeMin = Math.floor(timeS / 60);
        if (timeMin >= 60) {
          let timeHours = Math.floor(timeMin / 60);
          if (timeHours >= 24) {
            result = Math.floor(timeHours / 24) + "d";
            let hour = timeHours % 24;
            if (hour) {
              result += hour + "h";
            }
          } else {
            result = timeHours + "h";
            let min = timeMin % 60;
            if (min) {
              result += min + "min";
            }
          }
        } else {
          let sec = timeS % 60;
          result = timeMin + "min";
          if (sec) {
            result += sec + "s";
          }
        }
      } else {
        result = timeS + "s";
      }

      return result;
    }

    function toPrecisionIfNotInt(number) {
      // Because of floating point representations, we can get numbers like
      // 8.000000000000007. Treat them as if they were integers.
      let isAlmostInt = Math.round(number) == Math.round(number * 1000) / 1000;
      return isAlmostInt ? Math.round(number)
                         : number.toPrecision(3);
    }

    const nbsp = "&nbsp;";
    function formatPower(powerW, separator = nbsp) {
      if (powerW < 1 && powerW > 0) {
        return toPrecisionIfNotInt(powerW * 1000) + separator + "mW";
      }

      if (powerW > 1000) {
        return toPrecisionIfNotInt(powerW / 1000) + separator + "kW";
      }

      return toPrecisionIfNotInt(powerW) + separator + "W";
    }

    function formatEnergy(energyWh, separator = nbsp) {
      if (energyWh < 1 && energyWh > 0) {
        return toPrecisionIfNotInt(energyWh * 1000) + separator + "mWh";
      }

      if (energyWh > 1000) {
        return toPrecisionIfNotInt(energyWh / 1000) + separator + "kWh";
      }

      return toPrecisionIfNotInt(energyWh) + separator + "Wh";
    }

    function formatVoltage(voltageV) {
      return (Math.round(voltageV * 10) / 10) + nbsp + "V";
    }

    function calculateMedian(data) {
      // Quickselect algorithm for finding median in O(n) average time
      const arr = data.slice();
      const k = Math.floor(arr.length / 2);

      function partition(arr, left, right) {
        const pivot = arr[right];
        let i = left;

        for (let j = left; j < right; ++j) {
          if (arr[j] <= pivot) {
            [arr[i], arr[j]] = [arr[j], arr[i]];
            ++i;
          }
        }
        [arr[i], arr[right]] = [arr[right], arr[i]];
        return i;
      }

      function quickselect(arr, left, right, k) {
        if (left === right) return arr[left];

        const pivotIndex = partition(arr, left, right);

        if (k === pivotIndex) {
          return arr[k];
        } else if (k < pivotIndex) {
          return quickselect(arr, left, pivotIndex - 1, k);
        } else {
          return quickselect(arr, pivotIndex + 1, right, k);
        }
      }

      return quickselect(arr, 0, arr.length - 1, k);
    }

    function setDeviceName(name) {
      deviceName = name;
      document.title = `${deviceName} power profiling`;
      setText("deviceNameProfile", deviceName);
      setText("deviceNameH1", ": " + deviceName);
    }

    async function getDeviceName() {
      let url = `ws://${document.getElementById("ip").value}/rpc`;

      let socket = new WebSocket(url);
      socket.onmessage = (event) => {
        let message = JSON.parse(event.data);
        if (message.id == 1) {
          deviceInfo = message.result; // Store full device info
          setDeviceName(deviceInfo.name || ("Shelly " + deviceInfo.app));
          socket.close();
        }
      };
      socket.onopen = (event) => {
        socket.send('{"id":1,"method":"Shelly.GetDeviceInfo"}');
      }
    }

    async function fetchSamples() {
      updateStatus(true);

      let url = `http://${document.getElementById("ip").value}/${document.getElementById("scriptPath").value}`;
      if (shellyPlusLastIndex > 0) {
        url += "?" + (shellyPlusLastIndex);
      }

      let data;
      try {
        let response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        data = await response.json();
      } catch (error) {
        console.error("Failed to fetch samples:", error);
        lastError = error.message;
        updateStatus();
        return;
      }

      // Process the received data
      if (shellyPlusLastIndex == -1) {
        // multiple power meters: power_values is an array power values.
        if (Array.isArray(data.power_values[0])) {
          shellySwitchPowerData = data.power_values.map(arr => arr.slice());
          // Compute totals from switch data
          shellyPlusPowerData = [];
          for (let i = 0; i < data.power_values[0].length; ++i) {
            let total = 0;
            for (let switchId = 0; switchId < data.power_values.length; ++switchId) {
              if (i < data.power_values[switchId].length) {
                total += data.power_values[switchId][i];
              }
            }
            shellyPlusPowerData.push(total);
          }
        } else {
          // Single power meter format
          shellyPlusPowerData = data.power_values.slice();
        }

        if (data.voltage_values) {
          shellyPlusVoltageData = data.voltage_values.slice();
        } else {
          document.getElementById("voltageHeaderRow").remove();
          document.getElementById("voltageRow").remove();
        }
        if (data.freq_values) {
          shellyPlusFreqData = data.freq_values.slice();
          shellyPlusPfData = data.pf_values.slice();
        }
        shellyPlusLastIndex = data.start_index + shellyPlusPowerData.length;

        // Show content and update time for initial data
        if (shellyPlusPowerData.length > 0) {
          lastUpdateTime = Date.now();
          document.querySelector('.content').classList.add('has-data');
        }
      } else if (shellyPlusLastIndex < data.start_index + (Array.isArray(data.power_values[0]) ? data.power_values[0].length : data.power_values.length)) {
        let sliceStart = shellyPlusLastIndex - data.start_index;

        if (Array.isArray(data.power_values[0])) {
          // multiple power meters for format
          for (let switchId = 0; switchId < data.power_values.length; ++switchId) {
            let newSwitchData = data.power_values[switchId].slice(sliceStart);
            if (shellySwitchPowerData[switchId]) {
              shellySwitchPowerData[switchId] = shellySwitchPowerData[switchId].concat(newSwitchData);
            } else {
              shellySwitchPowerData[switchId] = newSwitchData;
            }
          }
          // Compute new total data
          for (let i = 0; i < data.power_values[0].length - sliceStart; ++i) {
            let total = 0;
            for (let switchId = 0; switchId < data.power_values.length; ++switchId) {
              if (sliceStart + i < data.power_values[switchId].length) {
                total += data.power_values[switchId][sliceStart + i];
              }
            }
            shellyPlusPowerData.push(total);
          }
        } else {
          // Single power meter format
          let newPowerData = data.power_values.slice(sliceStart);
          shellyPlusPowerData = shellyPlusPowerData.concat(newPowerData);
        }

        if (data.voltage_values) {
          let newVoltageData = data.voltage_values.slice(sliceStart);
          shellyPlusVoltageData = shellyPlusVoltageData.concat(newVoltageData);
        }
        if (data.freq_values) {
          let newFreqData = data.freq_values.slice(sliceStart);
          shellyPlusFreqData = shellyPlusFreqData.concat(newFreqData);
          let newPfData = data.pf_values.slice(sliceStart);
          shellyPlusPfData = shellyPlusPfData.concat(newPfData);
        }

        let dataLength = Array.isArray(data.power_values[0]) ? data.power_values[0].length - sliceStart : data.power_values.length - sliceStart;
        shellyPlusLastIndex += dataLength;

        // Update last update time only when we actually receive new samples
        if (dataLength > 0) {
          lastUpdateTime = Date.now();
        }
      } else {
        console.log("unexpected", data);
      }
      setText("sampleCount", shellyPlusPowerData.length);
      setText("lastPower", formatPower(shellyPlusPowerData.at(-1)));
      if (shellyPlusVoltageData.length) {
        setText("lastVoltage", formatVoltage(shellyPlusVoltageData.at(-1)));
      }

      // Update individual switch power values display
      if (shellySwitchPowerData.length > 0) {
        const switchPowerLine = document.getElementById("switchPowerLine");

        // Initialize spans if they don't exist yet
        if (switchPowerLine.children.length === 0) {
          for (let switchId = 0; switchId < shellySwitchPowerData.length; switchId++) {
            let switchData = shellySwitchPowerData[switchId];
            if (switchData && switchData.length > 0) {
              const span = document.createElement('span');
              const switchName = switchNames[switchId] || `Switch ${switchId}`;
              span.innerHTML = `<span class="switch-name" data-switch-id="${switchId}">${switchName}</span>: <span class="power-value">${formatPower(switchData.at(-1), ' ')}</span>`;

              // Add hover event to compute stats on demand
              span.addEventListener('mouseenter', () => {
                const currentData = shellySwitchPowerData[switchId];
                if (currentData && currentData.length > 0) {
                  const max = Math.max(...currentData);
                  const sum = currentData.reduce((a, b) => a + b, 0);
                  const average = sum / currentData.length;
                  const median = calculateMedian(currentData);
                  const energy = sum / 3600; // Convert Ws to Wh

                  // Create tooltip content using regular spaces
                  const tooltipContent = `Median: ${formatPower(median, ' ')}
Average: ${formatPower(average, ' ')}
Max: ${formatPower(max, ' ')}
Total Energy: ${formatEnergy(energy, ' ')}`;
                  span.title = tooltipContent;
                }
              });

              switchPowerLine.appendChild(span);
            }
          }

          // Add click listeners to switch names
          document.querySelectorAll('.switch-name').forEach(nameElement => {
            nameElement.addEventListener('click', (e) => {
              e.preventDefault();
              editSwitchName(nameElement);
            });
          });
        } else {
          // Update only the power values in existing spans
          for (let switchId = 0; switchId < shellySwitchPowerData.length; switchId++) {
            let switchData = shellySwitchPowerData[switchId];
            if (switchData && switchData.length > 0 && switchId < switchPowerLine.children.length) {
              const span = switchPowerLine.children[switchId];
              const powerValueElement = span.querySelector('.power-value');
              if (powerValueElement) {
                powerValueElement.textContent = formatPower(switchData.at(-1), ' ');
              }
            }
          }
        }
      }

      showGraph();

      // Update status on success
      lastError = null;
      updateStatus();
    }

    const graphHeight = 120;
    const graphWidth = 2400;
    const halfStrokeWidth = 3;
    function makeSVGPath(powerData, maxPower) {
      let lastLetter = "";
      function letter(l) {
        if (l == lastLetter) {
          return "";
        }
        lastLetter = l;
        return l;
      }
      let path;
      function append(cmd) {
        if (/^\d/.test(cmd) && /\d$/.test(path)) {
          path += " ";
        }
        path += cmd;
      }
      let x = i => Math.round((i / (powerData.length - 1)) * graphWidth);
      let y = i => powerData[i] == 0 ? graphHeight + halfStrokeWidth
          : Math.round(Math.max(halfStrokeWidth, (1 - powerData[i] / maxPower) * graphHeight));
      let lastX = -halfStrokeWidth * 2;
      let lastY = y(0);
      path = `${letter('M')}${lastX} ${graphHeight}V${lastY}`;
      for (let i = 0; i < powerData.length; ++i) {
        let xi = x(i);
        let yi = y(i);
        if (xi == lastX && yi == lastY) {
          continue;
        }
        if (yi == lastY) {
          while (i + 1 < powerData.length && y(i + 1) == lastY) {
            xi = x(++i);
          }
          append(`${letter('h')}${xi - lastX}`);
        } else {
          if (xi == lastX) {
            let ys = [yi];
            let j = 1;
            while (i + j < powerData.length && x(i + j) == xi) {
              ys.push(y(i + j));
              ++j;
            }
            let usefulYs = [];
            let max = Math.max(...ys);
            let min = Math.min(...ys);
            let last = ys[ys.length - 1];
            if (max != last && max > lastY) {
              usefulYs.push(max);
            }
            if (min != last && min < lastY) {
              usefulYs.push(min);
            }
            usefulYs.push(last);

            i += j - 1;
            for (let usefulY of usefulYs) {
              yi = usefulY;
              let v = `${lastLetter != 'v' ? 'v' : ''}${yi - lastY}`;
              let V = `${lastLetter != 'V' ? 'V' : ''}${yi}`;
              if (v.length <= V.length) {
                append(v);
                lastLetter = 'v';
              } else {
                append(V);
                lastLetter = 'V';
              }
              lastY = yi;
            }
          } else {
            append(`${letter('l')}${xi - lastX}`);
            append(`${yi - lastY}`);
          }
        }
        lastX = xi;
        lastY = yi;
      }
      path += `H${graphWidth + halfStrokeWidth * 2}V${graphHeight}`;

      return path;
    }

    // Cached statistics to avoid recalculation
    let cachedStats = {
      maxPower: 0,
      energyWs: 0,
      minVoltage: Infinity,
      maxVoltage: -Infinity,
      sumVoltage: 0
    };
    let processedSamples = 0;

    // Status tracking
    let lastUpdateTime = null;
    let lastError = null;

    function setIndicatorStatus(status) {
      const indicator = document.getElementById("statusIndicator");
      indicator.classList.remove('fetching', 'waiting', 'error', 'stale');
      if (status) {
        indicator.classList.add(status);
      }
    }

    function updateStatus(isFetching) {
      if (document.hidden) {
        return;
      }

      let message;
      if (lastError) {
        message = `Error: ${lastError}`;
        setIndicatorStatus('error');
      } else if (lastUpdateTime) {
        message = `Last update: ${new Date(lastUpdateTime).toLocaleTimeString()}`;
        const isStale = (Date.now() - lastUpdateTime >= UPDATE_INTERVAL_MS * 2);
        setIndicatorStatus(isStale ? 'stale' : isFetching ? 'fetching' : 'waiting');
      } else {
        // "Waiting for initial data..." is already in the initial HTML.
        return;
      }
      document.getElementById("statusText").textContent = message;
    }

    function showGraph() {
      // Early return if page is hidden or no new data to process
      if (document.hidden || processedSamples >= shellyPlusPowerData.length) {
        return;
      }

      // Update cached statistics for new samples only
      while (processedSamples < shellyPlusPowerData.length) {
        const power = shellyPlusPowerData[processedSamples];
        if (power > cachedStats.maxPower) cachedStats.maxPower = power;
        cachedStats.energyWs += power;

        if (shellyPlusVoltageData.length) {
          const voltage = shellyPlusVoltageData[processedSamples];
          if (voltage < cachedStats.minVoltage) cachedStats.minVoltage = voltage;
          if (voltage > cachedStats.maxVoltage) cachedStats.maxVoltage = voltage;
          cachedStats.sumVoltage += voltage;
        }

        ++processedSamples;
      }

      document.querySelector("#totalChart path").setAttribute("d", makeSVGPath(shellyPlusPowerData, cachedStats.maxPower));

      setText("maxPower", formatPower(cachedStats.maxPower));
      setText("totalTime", formatDuration(shellyPlusPowerData.length));
      setText("averagePower", formatPower(cachedStats.energyWs / shellyPlusPowerData.length));
      setText("medianPower", formatPower(calculateMedian(shellyPlusPowerData)));
      setText("totalEnergy", formatEnergy(cachedStats.energyWs / 3600));

      if (shellyPlusVoltageData.length) {
        setText("minVoltage", formatVoltage(cachedStats.minVoltage));
        setText("averageVoltage", formatVoltage(cachedStats.sumVoltage / shellyPlusVoltageData.length));
        setText("maxVoltage", formatVoltage(cachedStats.maxVoltage));
      }

      // Update individual switch data if available
      if (shellySwitchPowerData.length > 0) {

        // Create switch chart divs if not already created
        if (!switchChartsCreated) {
          const chartContainer = document.getElementById("chartContainer");
          const totalChart = document.getElementById("totalChart");

          for (let i = 0; i < shellySwitchPowerData.length; ++i) {
            const switchChart = document.createElement('div');
            switchChart.id = `switch${i}Chart`;
            switchChart.innerHTML = '<svg viewBox="0 0 2400 120"><path d=""/></svg>';
            switchChart.dataset.switchId = i;
            chartContainer.insertBefore(switchChart, totalChart);

            // Add mouse event listeners for tooltip
            addChartTooltip(switchChart, () => shellySwitchPowerData[i], i);
          }

          // Update the main chart tooltip to show "Total:" now that we have switches
          addChartTooltip(totalChart, () => shellyPlusPowerData, 'total');

          switchChartsCreated = true;
        }

        for (let switchId = 0; switchId < shellySwitchPowerData.length; switchId++) {
          let switchData = shellySwitchPowerData[switchId];
          if (switchData && switchData.length > 0) {
            // Calculate max for chart scaling
            let max = Math.max(...switchData);

            // Draw individual switch chart
            let switchChart = document.querySelector(`#switch${switchId}Chart path`);
            switchChart.setAttribute("d", makeSVGPath(switchData, max));
          }
        }
      }
    }

    function editSwitchName(nameElement) {
      const switchId = parseInt(nameElement.dataset.switchId);
      const currentName = nameElement.textContent;

      // Create input element
      const input = document.createElement('input');
      input.type = 'text';
      input.value = currentName;
      input.style.width = '100px';
      input.style.fontSize = 'inherit';
      input.style.fontFamily = 'inherit';

      // Replace the name element with input
      nameElement.parentNode.replaceChild(input, nameElement);
      input.focus();
      input.select();

      input.addEventListener('blur', () => {
        const newName = input.value.trim() || `Switch ${switchId}`;
        switchNames[switchId] = newName;
        updateUrlHash();
        nameElement.textContent = newName;
        input.parentNode.replaceChild(nameElement, input);
      });

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          input.blur();
        } else if (e.key === 'Tab') {
          e.preventDefault();
          input.blur();
          const targetSwitchId = e.shiftKey ? switchId - 1 : switchId + 1;
          const targetNameElement = document.querySelector(`.switch-name[data-switch-id="${targetSwitchId}"]`);
          if (targetNameElement) {
            setTimeout(() => editSwitchName(targetNameElement), 0);
          }
        } else if (e.key === 'Escape') {
          nameElement.textContent = currentName;
          input.parentNode.replaceChild(nameElement, input);
        }
      });
    }

    function updateUrlHash() {
      const params = new URLSearchParams();

      // Add custom switch names (only if different from default)
      for (const [switchId, customName] of Object.entries(switchNames)) {
        const defaultName = `Switch ${switchId}`;
        if (customName && customName !== defaultName) {
          params.set(`s${switchId}`, customName);
        }
      }

      if (params.toString()) {
        location.hash = params.toString();
      } else {
        // Remove hash if no custom names
        if (location.hash) {
          history.replaceState(null, null, ' ');
        }
      }
    }

    // Add tooltip functionality
    let tooltip = null;
    let hoverDot = null;

    function addChartTooltip(chartDiv, getDataArray, switchId = null) {
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.className = 'chart-tooltip';
        document.body.appendChild(tooltip);
      }

      const svg = chartDiv.querySelector('svg');
      if (!svg) return;

      // Create hover dot if it doesn't exist
      if (!hoverDot) {
        hoverDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        hoverDot.setAttribute('r', '9');
        hoverDot.style.display = 'none';
      }

      svg.addEventListener('mousemove', (e) => {
        const dataArray = getDataArray();
        if (!dataArray || dataArray.length === 0) return;

        const rect = svg.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const xRatio = x / rect.width;
        const dataIndex = Math.min(Math.floor(xRatio * dataArray.length), dataArray.length - 1);

        if (dataIndex >= 0 && dataIndex < dataArray.length) {
          const power = dataArray[dataIndex];
          let content;
          if (switchId === 'total') {
            content = `Total: ${formatPower(power)}`;
          } else if (switchId !== null) {
            const switchName = switchNames[switchId] || `Switch ${switchId}`;
            content = `${switchName}: ${formatPower(power)}`;
          } else {
            content = formatPower(power);
          }
          tooltip.innerHTML = content;
          tooltip.style.display = 'block';
          tooltip.style.left = e.pageX + 10 + 'px';
          tooltip.style.top = e.pageY - 30 + 'px';

          // Position and show the hover dot
          const xPosition = (dataIndex / (dataArray.length - 1)) * 2400;
          const maxPower = Math.max(...dataArray);
          const yPosition = maxPower > 0 ? 120 - (power / maxPower) * 120 : 60;

          hoverDot.setAttribute('cx', xPosition);
          hoverDot.setAttribute('cy', yPosition);
          hoverDot.style.display = 'block';

          // Add dot to current SVG if not already there
          if (!svg.contains(hoverDot)) {
            svg.appendChild(hoverDot);
          }
        }
      });

      svg.addEventListener('mouseleave', () => {
        if (tooltip) tooltip.style.display = 'none';
        if (hoverDot) hoverDot.style.display = 'none';
      });
    }

    // Add tooltip to the main chart (will be updated when we know if there are switches)
    addChartTooltip(document.getElementById('totalChart'), () => shellyPlusPowerData, null);

    setInterval(fetchSamples, UPDATE_INTERVAL_MS);
    getDeviceName();
    fetchSamples();
    updateStatus();

    function downloadCsv(event) {
      let mimeType = "text/plain";
      let data;

      if (shellySwitchPowerData.length > 0) {
        // For power strip, include header and individual switch data
        let header = "Total Power";
        for (let i = 0; i < shellySwitchPowerData.length; ++i) {
          const switchName = switchNames[i] || `Switch ${i}`;
          header += `,${switchName}`;
        }
        data = header + "\n";

        for (let i = 0; i < shellyPlusPowerData.length; ++i) {
          let row = shellyPlusPowerData[i];
          for (let switchId = 0; switchId < shellySwitchPowerData.length; switchId++) {
            if (shellySwitchPowerData[switchId] && i < shellySwitchPowerData[switchId].length) {
              row += "," + shellySwitchPowerData[switchId][i];
            } else {
              row += ",0";
            }
          }
          data += row + "\n";
        }
      } else {
        // Standard single power value per line
        data = shellyPlusPowerData.join("\n");
      }

      let url = URL.createObjectURL(
        new Blob([data], { type: mimeType })
      );
      event.target.href = url;
      event.target.download = `${new Date().toDateString()} - ${document.getElementById("sampleCount").innerText} samples.csv`;
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    function counterObject(name, description, times, samples) {
      let time = [];
      // Remove consecutive 0 samples.
      let count = samples.filter((sample, index) => {
	let keep =
          sample != 0 ||
          index == 0 || index == samples.length - 1 ||
          samples[index - 1] != 0 || samples[index + 1] != 0;
	if (keep) {
	  time.push(times[index])
	}
	return keep;
      });
      return {
        name,
        category: "power",
        description,
        pid: "0",
        mainThreadIndex: 0,
        samples: {
          time, count, length: count.length
        }
      }
    }
    function WattSecondToPicoWattHour(value) {
      return Math.round(value / 3600 * 1e12);
    }
    function makeProfile() {
      const baseProfile = '{"meta":{"interval":1000,"startTime":0,"abi":"","misc":"","oscpu":"","platform":"","processType":0,"extensions":{"id":[],"name":[],"baseURL":[],"length":0},"categories":[{"name":"Other","color":"grey","subcategories":["Other"]}],"product":"Home power profiling","stackwalk":0,"toolkit":"","version":27,"preprocessedProfileVersion":48,"appBuildID":"","sourceURL":"","physicalCPUs":1,"logicalCPUs":0,"CPUName":"Shelly Plus","symbolicationNotSupported":true,"markerSchema":[]},"libs":[],"pages":[],"threads":[{"processType":"default","processStartupTime":0,"processShutdownTime":null,"registerTime":0,"unregisterTime":null,"pausedRanges":[],"name":"GeckoMain","isMainThread":true,"pid":"0","tid":0,"samples":{"weightType":"samples","weight":null,"eventDelay":[],"stack":[],"time":[],"length":0},"markers":{"data":[],"name":[],"startTime":[],"endTime":[],"phase":[],"category":[],"length":0},"stackTable":{"frame":[0],"prefix":[null],"category":[0],"subcategory":[0],"length":1},"frameTable":{"address":[-1],"inlineDepth":[0],"category":[null],"subcategory":[0],"func":[0],"nativeSymbol":[null],"innerWindowID":[0],"implementation":[null],"line":[null],"column":[null],"length":1},"stringTable":{"_array":["(root)"],"_stringToIndex":{}},"funcTable":{"isJS":[false],"relevantForJS":[false],"name":[0],"resource":[-1],"fileName":[null],"lineNumber":[null],"columnNumber":[null],"length":1},"resourceTable":{"lib":[],"name":[],"host":[],"type":[],"length":0},"nativeSymbols":{"libIndex":[],"address":[],"name":[],"functionSize":[],"length":0}}],"counters":[]}';

      let profile = JSON.parse(baseProfile);
      // Return early if we have no data to profile
      if (shellyPlusPowerData.length === 0 && debugMessages.length === 0) {
        return null;
      }

      // Use actual start time based on when we started collecting data
      let startTime;
      if (lastUpdateTime && shellyPlusPowerData.length > 0) {
        startTime = lastUpdateTime - shellyPlusPowerData.length * 1000;
      } else {
        startTime = debugMessages[0].ts * 1000;
      }

      profile.meta.startTime = startTime;
      profile.meta.profilingStartTime = 0;

      // Profile end time is either power data length or last debug message
      let endTime = shellyPlusPowerData.length * 1000;
      if (debugMessages.length > 0) {
        const lastDebugTime = debugMessages.at(-1).ts * 1000;
        endTime = Math.max(endTime, lastDebugTime - startTime);
      }

      profile.meta.profilingEndTime = endTime;

      if (deviceInfo) {
        profile.meta.product = deviceName;
        profile.meta.device = deviceInfo.app;
        profile.meta.CPUName = `${deviceInfo.model} (Gen${deviceInfo.gen})`;
        profile.meta.platform = `Shelly Gen${deviceInfo.gen}`;
        if (deviceInfo.fw_id) {
          profile.meta.appBuildID = deviceInfo.fw_id;
        }
      }

      // Only preserve order if we have multiple tracks
      if (shellySwitchPowerData.length > 0) {
        profile.meta.keepProfileThreadOrder = true;
      }

      profile.meta.markerSchema = [
        {
          name: "volt",
          tooltipLabel: "{marker.data.v}",
          display: [],
          data: [{key: "v", label: "Voltage", format: "string"}],
          graphs: [{key: "v", color: "orange", type: "line-filled"}],
        },
        {
          name: "pf",
          tooltipLabel: "{marker.data.pf}",
          display: [],
          data: [{key: "pf", label: "Power factor", format: "string"}],
          graphs: [{key: "pf", color: "blue", type: "line-filled"}],
        },
        {
          name: "f",
          tooltipLabel: "{marker.data.f}",
          display: [],
          data: [{key: "f", label: "Frequency (Hz)", format: "string"}],
          graphs: [{key: "f", color: "grey", type: "line-filled"}],
        },
        {
          name: "memory",
          tooltipLabel: "RAM: {marker.data.ramUsed}/{marker.data.ramSize} bytes ({marker.data.usagePercent}%) | Free: {marker.data.ramFree}",
          display: [],
          data: [
            {key: "ramSize", label: "RAM Size (bytes)", format: "integer"},
            {key: "ramFree", label: "RAM Free (bytes)", format: "integer"},
            {key: "ramMinFree", label: "RAM Min Free (bytes)", format: "integer"},
            {key: "ramUsed", label: "RAM Used (bytes)", format: "integer"},
            {key: "usagePercent", label: "Usage %", format: "integer"}
          ],
          graphs: [{key: "usagePercent", color: "red", type: "line"}]
        },
        {
          name: "script-memory",
          tooltipLabel: "Script: {marker.data.memUsed} bytes used | Peak: {marker.data.memPeak} | Free: {marker.data.memFree} | Delta: {marker.data.memDelta} | Peak Delta: {marker.data.peakDelta}",
          display: [],
          data: [
            {key: "memUsed", label: "Script Memory Used (bytes)", format: "integer"},
            {key: "memPeak", label: "Script Memory Peak (bytes)", format: "integer"},
            {key: "memFree", label: "Available Memory (bytes)", format: "integer"},
            {key: "memDelta", label: "Memory Delta (bytes)", format: "integer"},
            {key: "peakDelta", label: "Peak Delta (bytes)", format: "integer"}
          ],
          graphs: [
            {key: "memUsed", color: "blue", type: "line"},
            {key: "memPeak", color: "purple", type: "line"},
            {key: "memFree", color: "green", type: "line"}
          ]
        },
        {
          name: "cpu",
          tooltipLabel: "CPU: {marker.data.cpu}%",
          display: [],
          data: [
            {key: "cpu", label: "CPU Usage (%)", format: "number"}
          ],
          graphs: [
            {key: "cpu", color: "green", type: "line"}
          ]
        }
      ];

      // Add debug schema only if we have debug messages
      if (debugMessages.length > 0) {
        profile.meta.markerSchema.push({
          name: "debug",
          tooltipLabel: "{marker.data.message}",
          tableLabel: "{marker.data.message}",
          display: ["marker-chart", "marker-table"],
          colorField: "color",
          data: [
            {key: "message", label: "Message", format: "string"},
            {key: "from", label: "From", format: "string"},
            {key: "level", label: "Level", format: "string"},
            {key: "color", format: "string", hidden: true},
            {key: "seq", label: "Sequence", format: "integer"}
          ]
        });
      }

      let times = shellyPlusPowerData.map((v, i) => i * 1000);
      let zeros = new Array(times.length).fill(0);

      let {samples, markers, stringTable} = profile.threads[0];
      samples.stack = zeros;
      samples.time = times;
      samples.length = times.length;

      profile.counters = [
        counterObject(deviceName,
                      `Data recorded by a ${deviceName} power meter`,
                      times, shellyPlusPowerData.map(WattSecondToPicoWattHour))
      ];

      // Add individual switch counters if available
      if (shellySwitchPowerData.length > 0) {
        for (let switchId = 0; switchId < shellySwitchPowerData.length; switchId++) {
          let switchData = shellySwitchPowerData[switchId];
          if (switchData && switchData.length > 0) {
            const switchName = switchNames[switchId] || `Switch ${switchId}`;
            profile.counters.push(
              counterObject(switchName,
                           `${switchName} data from ${deviceName} power strip`,
                           times.slice(0, switchData.length),
                           switchData.map(WattSecondToPicoWattHour))
            );
          }
        }
      }

      let voltageIndex = stringTable._array.length;
      stringTable._array.push("Voltage");
      for (let i = 0; i < shellyPlusVoltageData.length; ++i) {
        markers.startTime.push(times[i]);
        markers.endTime.push(times[i]);
        // 0 = Instant marker, 1 = marker with start and end times, 2 = start but no end.
        markers.phase.push(1)
        markers.category.push(0);
        markers.name.push(voltageIndex)
        markers.data.push({type: "volt", v: shellyPlusVoltageData[i]});
      }

      let freqIndex = stringTable._array.length;
      stringTable._array.push("Frequency");
      for (let i = 0; i < shellyPlusFreqData.length; ++i) {
        markers.startTime.push(times[i]);
        markers.endTime.push(times[i]);
        // 0 = Instant marker, 1 = marker with start and end times, 2 = start but no end.
        markers.phase.push(1)
        markers.category.push(0);
        markers.name.push(freqIndex)
        markers.data.push({type: "f", f: shellyPlusFreqData[i]});
      }

      let pfIndex = stringTable._array.length;
      stringTable._array.push("Power Factor");
      for (let i = 0; i < shellyPlusPfData.length; ++i) {
        markers.startTime.push(times[i]);
        markers.endTime.push(times[i]);
        // 0 = Instant marker, 1 = marker with start and end times, 2 = start but no end.
        markers.phase.push(1)
        markers.category.push(0);
        markers.name.push(pfIndex)
        markers.data.push({type: "pf", pf: shellyPlusPfData[i]});
      }

      // Add debug messages as markers if available
      for (const debugMsg of debugMessages) {
        // Convert Shelly timestamp to profile timestamp (milliseconds from start)
        const profileTime = (debugMsg.ts * 1000) - startTime;

        // Parse debug message format: "filename.ext:line   actual message"
        let markerName = "debug";
        let from = "";
        let cleanMessage = debugMsg.data.trim();

        // Check if message starts with filename:line pattern (with or without extension)
        const locationMatch = debugMsg.data.match(/^([^:\s]+(?:\.[^:\s]+)?):(\d+)\s+(.+)$/);
        if (locationMatch) {
          const fullFilename = locationMatch[1];
          const lineNum = locationMatch[2];
          cleanMessage = locationMatch[3];

          // Extract just filename without extension for marker name
          markerName = fullFilename.replace(/\.[^.]*$/, '');
          from = `${fullFilename}:${lineNum}`;
        }

        // Add the marker name to string table if not already present
        let nameIndex = stringTable._array.indexOf(markerName);
        if (nameIndex === -1) {
          nameIndex = stringTable._array.length;
          stringTable._array.push(markerName);
        }

        markers.startTime.push(profileTime);
        markers.endTime.push(profileTime);
        markers.phase.push(0); // Instant marker
        markers.category.push(0);
        markers.name.push(nameIndex);

        // Create descriptive level string
        const levelName = DEBUG_LEVELS[debugMsg.level] || 'UNKNOWN';
        const levelString = `${levelName} (${debugMsg.level})`;

        const markerData = {
          type: "debug",
          message: cleanMessage,
          seq: debugMsg.seq
        };

        if (from) {
          markerData.from = from;
        }

        if (levelName !== 'UNKNOWN') {
          markerData.level = levelString;
        }

        // Add color for ERROR and WARN levels
        if (levelName === 'ERROR') {
          markerData.color = 'red';
        } else if (levelName === 'WARN') {
          markerData.color = 'orange';
        }

        markers.data.push(markerData);
      }

      // Add memory usage markers if available
      for (const memoryPoint of memoryData) {
        const profileTime = (memoryPoint.ts * 1000) - startTime;

        // Add memory marker name to string table
        const memoryMarkerName = "Memory";
        let memoryNameIndex = stringTable._array.indexOf(memoryMarkerName);
        if (memoryNameIndex === -1) {
          memoryNameIndex = stringTable._array.length;
          stringTable._array.push(memoryMarkerName);
        }

        markers.startTime.push(profileTime);
        markers.endTime.push(profileTime);
        markers.phase.push(0); // Instant marker
        markers.category.push(0);
        markers.name.push(memoryNameIndex);
        const markerData = {
          type: "memory",
          ramSize: memoryPoint.ramTotal,
          ramFree: memoryPoint.ramFree,
          ramUsed: memoryPoint.ramUsed,
          usagePercent: memoryPoint.usagePercent
        };
        // Only include ramMinFree if it exists
        if (memoryPoint.ramMinFree !== undefined) {
          markerData.ramMinFree = memoryPoint.ramMinFree;
        }
        markers.data.push(markerData);
      }

      // Add script memory markers if available
      let prevMemoryData = null;
      for (const scriptMemPoint of scriptMemoryData) {
        const profileTime = (scriptMemPoint.ts * 1000) - startTime;

        // Calculate deltas from previous point
        let memDelta = 0;
        let peakDelta = 0;
        if (prevMemoryData) {
          memDelta = scriptMemPoint.memUsed - prevMemoryData.memUsed;
          peakDelta = scriptMemPoint.memPeak - prevMemoryData.memPeak;
        }

        // Add script memory marker name to string table
        const scriptMemMarkerName = "Script Memory";
        let scriptMemNameIndex = stringTable._array.indexOf(scriptMemMarkerName);
        if (scriptMemNameIndex === -1) {
          scriptMemNameIndex = stringTable._array.length;
          stringTable._array.push(scriptMemMarkerName);
        }

        markers.startTime.push(profileTime);
        markers.endTime.push(profileTime);
        markers.phase.push(0); // Instant marker
        markers.category.push(0);
        markers.name.push(scriptMemNameIndex);
        markers.data.push({
          type: "script-memory",
          memUsed: scriptMemPoint.memUsed,
          memPeak: scriptMemPoint.memPeak,
          memFree: scriptMemPoint.memFree,
          memDelta: memDelta,
          peakDelta: peakDelta
        });

        prevMemoryData = scriptMemPoint;
      }

      // Add CPU usage markers if available
      for (const cpuPoint of cpuData) {
        const profileTime = (cpuPoint.ts * 1000) - startTime;

        // Add CPU marker name to string table
        const cpuMarkerName = "CPU Usage";
        let cpuNameIndex = stringTable._array.indexOf(cpuMarkerName);
        if (cpuNameIndex === -1) {
          cpuNameIndex = stringTable._array.length;
          stringTable._array.push(cpuMarkerName);
        }

        markers.startTime.push(profileTime);
        markers.endTime.push(profileTime);
        markers.phase.push(0); // Instant marker
        markers.category.push(0);
        markers.name.push(cpuNameIndex);
        markers.data.push({
          type: "cpu",
          cpu: cpuPoint.cpu
        });
      }

      markers.length = markers.name.length;

      return profile;
    }

    function downloadProfile(event) {
      let mimeType = "application/json";
      let url = URL.createObjectURL(
        new Blob([JSON.stringify(makeProfile())], { type: mimeType })
      );
      event.target.href = url;
      event.target.download = `${new Date().toDateString()} - ${document.getElementById("sampleCount").innerText} samples.json`;
      setTimeout(() => URL.revokeObjectURL(url), 0);
    }

    async function openProfile(event) {
      event.preventDefault();
      const origin = "https://profiler.firefox.com";
      const profilerURL = origin + "/from-post-message/";
      const profilerWindow = window.open(profilerURL, "_blank");

      if (!profilerWindow) {
        console.error("Failed to open the new window.");
        return;
      }

      let isReady = false;
      window.addEventListener("message", function listener(event) {
        if (event.data && event.data.name === "ready:response") {
          window.removeEventListener("message", listener);
          isReady = true;
          const message = {
            name: "inject-profile",
            profile: makeProfile(),
          };
          profilerWindow.postMessage(message, origin);
        }
      });

      while (true) {
        await new Promise((resolve) => setTimeout(resolve, 100));
        if (isReady) {
          break;
        }
        profilerWindow.postMessage({ name: "ready:request" }, origin);
      }
    }

    document.getElementById("csv").addEventListener("click", downloadCsv);
    document.getElementById("profile").addEventListener("click", downloadProfile);
    document.getElementById("open").addEventListener("click", openProfile);
    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) {
        showGraph();
        updateStatus();
      }
    });
  </script>
  <footer>This work © 2024 — 2025 by Florian Quèze is licensed under <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="license noopener noreferrer">CC BY-NC 4.0<img src="https://mirrors.creativecommons.org/presskit/icons/cc.svg" alt="CC"><img src="https://mirrors.creativecommons.org/presskit/icons/by.svg" alt="BY"><img src="https://mirrors.creativecommons.org/presskit/icons/nc.svg" alt="NC"></a></footer>
</body>
</html>
